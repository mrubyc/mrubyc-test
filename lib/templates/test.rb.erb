#
# Generated by gem 'mrubyc_test' version: <%= Mrubyc::Test::VERSION %>
#
# Genarated at: <%= Time.now %>
# Your RUBY_DESCRIPTION: <%= RUBY_DESCRIPTION %>
#
# For more information, see <%= Gem.loaded_specs['mrubyc-test']&.homepage %>
#

if RUBY_ENGINE == 'mruby/c'
  class Math
  end
  class Numeric
  end
  RUBY_DESCRIPTION = 'mruby/c ' + MRUBYC_VERSION
else
  require_relative "./models.rb"
  require 'objspace'
  def debugprint(message)
    puts
    puts '==============================================================================='
    puts message
    puts "Object Space Memory used:#{ObjectSpace.memsize_of_all}"
    puts '==============================================================================='
    puts
  end
end
debugprint(RUBY_DESCRIPTION)
$success_count = 0
$failures = Array.new
$pendings = Array.new
$colors = {
  reset: "\e[0m",
  success: "\e[32m",
  failure: "\e[31m",
  pending: "\e[33m",
  info: "\e[36m"
}
def summerize
  failure_count = $failures.count
  pending_count = $pendings.count
  if pending_count > 0
    puts "Pendings:\n"
    $pendings.each_with_index do |pending, index|
      puts $colors[:pending]
      print index # FIXME: picorbc's bug :thinking_face:
      puts ") " + pending[:class_and_method]
      print $colors[:info]
      puts "  # " + pending[:path] + ":" + pending[:line]
      puts $colors[:reset]
    end
  end
  color = if failure_count > 0
    puts "Failures:\n"
    $failures.each_with_index do |failure, index|
      puts
      print index # FIXME: picorbc's bug :thinking_face:
      puts ") " + failure[:class_and_method] + " (:" + failure[:assertion] + ")"
      print $colors[:failure]
      puts "  description : " + failure[:description]
      puts "  expected    : " + failure[:expected] if failure[:expected].length > 0
      puts "  actual      : " + failure[:actual] if failure[:actual]
      puts "  error       : " + failure[:error] if failure[:error]
      puts "  message     : " + failure[:message] if failure[:message]
      print $colors[:info]
      puts "  # " + failure[:path] + ":" + failure[:line]
      print $colors[:reset]
    end
    $colors[:failure]
  elsif pending_count > 0
    $colors[:pending]
  else
    $colors[:success]
  end
  puts "\nFinished\n"
  print color
  print ($success_count + failure_count).to_s + ' examples, '
  print failure_count.to_s + ' failures, '
  print pending_count.to_s + ' (or more) pendings'
  puts $colors[:reset]
  puts
  (failure_count > 0) ? 1 : 0
end

<% %w(object hash mock mrubyc_test_case).each do |basename| -%>
  <%= File.read(File.join(mrubyc_class_dir, basename + '.rb')) %>
<% end -%>

<% test_files.each do |file_name| -%>
  <%= File.read(file_name).gsub(/(\bpend\b)/, '\1;return') -%>
<% end -%>

<% test_cases.each do |test_case| -%>
  <% case method_name_pattern
  when Regexp
    next unless method_name_pattern.match?(test_case[:information][:method_name])
  when String
    next unless method_name_pattern == test_case[:information][:method_name]
  end -%>
  <% test_case[:stubs].each do |stub| -%>
    class <%= stub[:class_name] %>
      attr_accessor <%= stub[:instance_variables] %>
      def <%= stub[:method_name] %>
        <% if stub[:return_value].is_a?(String) -%>
          "<%= stub[:return_value] %>"
        <% else -%>
          <%= stub[:return_value] %>
        <% end -%>
      end
    end
  <% end -%>
  <% test_case[:mocks].each do |mock| -%>
    class <%= mock[:class_name] %>
      def <%= mock[:method_name] %>(<%= mock[:method_parameters] %>)
        $mock.actual.add_by_key :<%= mock[:method_name] %>
      end
    end
  <% end -%>
  <% if test_case[:mocks].size > 0 -%>
    <% mrblib_classes = test_case[:mocks].map{ |item| item[:class_name] } -%>
    class MrubycTestCase
      def mock(object)
        <% mrblib_classes.each do |mrblib_class| -%>
          if object.to_s.include?('#<<%= mrblib_class %>:')
            <%= mrblib_class %>Double.new
          end
        <% end -%>
      end
    end
    <% test_case[:mocks].each do |mock| -%>
      class <%= mock[:class_name] %>Double
        def <%= mock[:method_name] %>(_param_size = 0)
          $mock.expected.add_by_key :<%= mock[:method_name] %>
        end
      end
    <% end -%>
  <% end -%>
  information = <%= test_case[:information].to_s %>
  puts
  $current_class_and_method = "<%= test_case[:information][:test_class_name] %>#<%= test_case[:information][:method_name] %>"
  puts $current_class_and_method
  begin
    my_case = <%= test_case[:information][:test_class_name] %>.new(information, <%= verbose.to_s %>)
    my_case.setup
    my_case.<%= test_case[:information][:method_name] %>
    <% if test_case[:mocks] -%>
      my_case.check_mock
    <% end -%>
    my_case.teardown
  rescue => e
    my_case.failure(nil, nil, "", e.message, e.class.to_s)
  end
  puts

<% end -%>

debugprint('finish test')

exit_code = summerize
exit(exit_code)

